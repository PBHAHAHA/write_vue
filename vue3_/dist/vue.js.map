{"version":3,"file":"vue.js","sources":["../src/shared/index.ts","../src/reactivity/reactive.ts","../src/reactivity/ref.ts","../src/reactivity/effect.ts","../src/reactivity/computed.ts"],"sourcesContent":["export const isObject = (val) => typeof val == 'object' && val !== null;","import { isObject } from \"../shared/index\";\r\n\r\nconst mutableHandlers = {\r\n    get(){\r\n\r\n    },\r\n    set(){\r\n\r\n    }\r\n}\r\n\r\nexport function reactive(target:object){\r\n    // 需要将target变成响应式的对象， Proxy\r\n\r\n    // 核心的操作就是当读取文件时做依赖收集，当数据变化时重新执行effect\r\n    return createReactiveObject(target,mutableHandlers);\r\n    \r\n}\r\n\r\nconst proxyMap = new WeakMap();\r\n\r\nfunction createReactiveObject(target,baseHandlers){\r\n    // 如果不是对象，只接返回\r\n    if(!isObject(target)){\r\n        return target\r\n    }\r\n\r\n    const exisitingProxy = proxyMap.get(target)\r\n    if(exisitingProxy){\r\n        return exisitingProxy\r\n    }\r\n    // 只是对最外层对象做代理，默认不会递归，而且不会重新重写对象中的属性\r\n    const proxy = new Proxy(target,baseHandlers)\r\n    proxyMap.set(target, proxy) //将代理的对象和代理的结果做一个映射表\r\n    return proxy\r\n}","export function ref(){\r\n    \r\n}","export function effect(){\r\n    \r\n}","export function computed(){\r\n    \r\n}"],"names":[],"mappings":";;;;;;IAAO,IAAM,QAAQ,GAAG,UAAC,GAAG,IAAK,OAAA,OAAO,GAAG,IAAI,QAAQ,IAAI,GAAG,KAAK,IAAI,GAAA;;ICEvE,IAAM,eAAe,GAAG;QACpB,GAAG;SAEF;QACD,GAAG;SAEF;KACJ,CAAA;aAEe,QAAQ,CAAC,MAAa;;;QAIlC,OAAO,oBAAoB,CAAC,MAAM,EAAC,eAAe,CAAC,CAAC;IAExD,CAAC;IAED,IAAM,QAAQ,GAAG,IAAI,OAAO,EAAE,CAAC;IAE/B,SAAS,oBAAoB,CAAC,MAAM,EAAC,YAAY;;QAE7C,IAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAC;YACjB,OAAO,MAAM,CAAA;SAChB;QAED,IAAM,cAAc,GAAG,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;QAC3C,IAAG,cAAc,EAAC;YACd,OAAO,cAAc,CAAA;SACxB;;QAED,IAAM,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,EAAC,YAAY,CAAC,CAAA;QAC5C,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,CAAC,CAAA;QAC3B,OAAO,KAAK,CAAA;IAChB;;aCnCgB,GAAG;IAEnB;;aCFgB,MAAM;IAEtB;;aCFgB,QAAQ;IAExB;;;;;;;;;;;;;"}